import mathimport numpy as npimport numpy.ma as maimport rasterioimport osfrom numpy.random import RandomStatefrom warnings import warndef specificity_score(y_true, y_pred):    """    Calculate specificity score    Args    ----    y_true: 1D numpy array        Truth values    y_pred: 1D numpy array        Predicted classes    Returns    -------    specificity: specificity score    """    from sklearn.metrics import confusion_matrix    cm = confusion_matrix(y_true, y_pred)    tn = float(cm[0][0])    fp = float(cm[0][1])    return tn/(tn+fp)def spatial_loocv(estimator, X, y, coordinates, size, radius, sampling=None,                  random_state=None):    """    Spatially Buffered Leave-One-out    adapted from R code    https://davidrroberts.wordpress.com/2016/03/11/spatial-leave-one-out-sloo-cross-validation/    Args    ----    size: int        sample size to process (number of LOO runs)    radius: int or float        radius for the spatial buffer around test point        Returns    -------    y_test: 1d numpy array        Response variable values in the test partitions    y_pred: 1d numpy array        Predicted response values by the estimator    y_prob:        Predicted probabilities by the estimator    """    # determine number of classes and features    n_classes = len(np.unique(y))    n_features = X.shape[1]    rstate = RandomState(random_state)    # randomly select the testing points    ind = rstate.choice(range(X.shape[0]), size)    X_test = X[ind, :]    y_test = y[ind]    coordinates_test = coordinates[ind, :]    # variables to store predictions and probabilities    y_pred = np.empty((0,))    y_prob = np.empty((0, n_classes))    # loop through the testing points    for i in range(size):        # Training data (test point & buffer removed)        # empty numpy arrays to append training that is > radius from test loc        X_train = np.empty((0, n_features))        y_train = np.empty((0))        # loop through each point in the original training data        # and append to X_train, y_train if coordinates > minimum radius        for j in range(X.shape[0]):            if math.sqrt((coordinates[j, 0] - coordinates_test[i, 0])**2 +                         (coordinates[j, 1] - coordinates_test[i, 1])**2) \                          > radius:                X_train = np.vstack((X_train, X[j]))                y_train = np.append(y_train, y[j])        # balancing        if sampling is not None:            X_train, y_train = sampling.fit_sample(X_train, y_train)        # Build the model        estimator.fit(X_train, y_train)        # Predict on test point        y_pred = np.append(y_pred, estimator.predict(X_test[i].reshape(1, -1)))        y_prob = np.vstack((            y_prob, estimator.predict_proba(X_test[i].reshape(1, -1))))    return (y_test, y_pred, y_prob)def printProgressBar(iteration, total, prefix = '', suffix = '', decimals = 1,                     length = 100, fill = 'â–ˆ'):    """    Call in a loop to create terminal progress bar    https://stackoverflow.com/questions/3173320/text-progress-bar-in-the-console/27871113        Args    ----    iteration: int        Current iteration    total: int        Total iterations    prefix: str, optional        prefix string (Str)    suffix: str, optional        suffix    decimals: int, optional        Positive number of decimals in percent complete    length: int, optional        Character length of bar    fill: str, optional        bar fill character    """    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))    filledLength = int(length * iteration // total)    bar = fill * filledLength + '-' * (length - filledLength)    print('\r%s |%s| %s%% %s' % (prefix, bar, percent, suffix), end = '\r')    # Print New Line on Complete    if iteration == total:         print()def __check_alignment(predictors):    """    Check that a list of rasters are aligned with the same pixel dimensions    and geotransforms        Args    ----    predictors: list (str)        List of file paths to the rasters        Returns    -------    src_meta: Dict        Dict containing raster metadata    """        src_meta = []    for raster in predictors:        src = rasterio.open(raster)        src_meta.append(src.meta.copy())        src.close()        if not all(i['crs']==src_meta[0]['crs'] for i in src_meta):        warn('crs of all rasters does not match, possible unintended consequences')    if not all([i['height']==src_meta[0]['height'] or                 i['width']==src_meta[0]['width'] or                i['transform']==src_meta[0]['transform'] for i in src_meta]):        print('Predictor rasters do not all have the same dimensions or',              'transform')        print('Use the .utils_align_rasters function')        return(False)    else:        return(src_meta[0])def raster_prediction(estimator, predictor_rasters, output, predict_type='raw',                      index=None, rowchunk=25):    """    Prediction on list of GDAL rasters using a fitted scikit learn model    Args    ----    estimator: estimator object implementing 'fit'        The object to use to fit the data.    predictor_rasters: list, comprising str        List of paths to GDAL rasters that are to be used in the prediction.        Note the order of the rasters in the list needs to be of the same        order and length of the data that was used to train the estimator    output: str        Path to a GeoTiff raster for the classification results    predict_type: str, optional (default='raw')        'raw' for classification/regression        'prob' for probabilities,        'all' for both classification and probabilities    index: List, int, optional        List of class indices to export    rowchunk: int, optional (default=25)        Number of raster rows to process at one time    """    if isinstance(index, int):        index = [index]            # check that all rasters are aligned    src_meta = __check_alignment(predictor_rasters)    if src_meta is False:        raise ValueError()    rows, cols = src_meta['height'], src_meta['width']        # Get the processing region dimensions    n_features = len(predictor_rasters)        # create lists of row increments, tuple (startrow, endrow, n_rows)    windows = []    for row in range(0, rows, rowchunk):        if row+rowchunk > rows:            rowincr = rows - row        else:            rowincr = rowchunk        windows.append((row, row+rowincr, rowincr))    # Loop through rasters block-by-block    for start, end, blocksize in windows:        printProgressBar(start, rows, length=50)        # create np 3D numpy array        img_np = ma.empty((blocksize, cols, n_features))        # loop through each rowblock, and each band and add these values        # to the 2D array img_np_row        for f in range(n_features):            img_np[:, :, f] = (                rasterio.open(predictor_rasters[f]).read(                    1, masked=True, window=((start, end), (0, cols))))        # reshape each image block matrix into a 1D matrix        # the scikit learn predict function expects a list of pixels        # not an NxM matrix        n_samples = blocksize * cols        flat_pixels = img_np.reshape((n_samples, n_features))        flat_pixels = ma.masked_invalid(flat_pixels)        # create mask for NaN values and replace with number        flat_pixels_mask = np.isnan(flat_pixels)  # True means invalid        flat_pixels = ma.filled(flat_pixels, fill_value=0)        # perform the prediction for classification        if predict_type == 'raw' or predict_type == 'all':            result_cla = estimator.predict(flat_pixels)            # replace mask            result_cla = np.ma.masked_array(                result_cla, mask=flat_pixels_mask.mask.any(axis=1))            result_cla = ma.filled(result_cla, fill_value=-99999)            # reshape the prediction from a 1D matrix/list            # back into the original format            result_cla = result_cla.reshape((blocksize, cols))            # write rowchunks to rasterio raster            if start == 0:                clf_output = rasterio.open(                    output, mode='w', driver='GTiff', height=rows, width=cols,                    count=1, dtype='float32', crs=src_meta['crs'],                    transform=src_meta['transform'], nodata=-99999)            clf_output.write(                result_cla.reshape((blocksize, cols)).astype('float32'),                window=((start, end), (0, cols)), indexes=1)        # perform the prediction for probabilities        if predict_type == 'prob' or predict_type == 'all':            result_proba = estimator.predict_proba(flat_pixels)            if start == 0:                if index is None:                    index = range(result_proba.shape[1])                    n_bands = len(index)                else:                    n_bands = len(np.unique(index))                fname, ext = os.path.basename(output).split(os.path.extsep)                output_proba = os.path.join(                    os.path.dirname(output),                    fname + '_proba' +                    os.path.extsep + ext)                proba_output = rasterio.open(                    output_proba, mode='w', driver='GTiff', height=rows,                    width=cols, count=n_bands, dtype='float32',                    crs=src_meta['crs'], transform=src_meta['transform'],                    nodata=-99999)            for i_class, label in enumerate(index):                result_proba_i = result_proba[:, label]                # replace mask                result_proba_i = np.ma.masked_array(                    result_proba_i, mask=flat_pixels_mask.mask.any(axis=1),                    fill_value=np.nan)                result_proba_i = ma.filled(                    result_proba_i, fill_value=-99999)                # reshape the prediction from a 1D matrix/list back into the                # original format                result_proba_i = result_proba_i.reshape((blocksize, cols))                # write rowchunks to rasterio raster                proba_output.write(                    result_proba_i.astype('float32'),                    window=((start, end), (0, cols)),                    indexes=1+i_class)                if predict_type == 'raw' or predict_type == 'all':        clf_output.close()    if predict_type == 'prob' or predict_type == 'all':        proba_output.close()